[
    {
        "id": "0e5ee74342c0495d",
        "type": "subflow",
        "name": "Calculate Weighted Average",
        "info": "<div>\n  <p>\n    This subflow calculates the weighted average of given values, considering the date of each value.\n    The more recent the date, the higher the value will be weighted in the average calculation.\n  </p>\n  <p>\n    It takes as input a list with the following structure (put this in the <code>msg.payload</code>):\n    <code>\n      {\n        \"attr_name1\": [\n          {\"value\": x, \"date\": y},\n          {\"value\": z, \"date\": e}\n        ],\n        \"attr_name2\": [\n          {\"value\": q, \"date\": w},\n          ...\n        ]\n      }\n    </code>\n  </p>\n  <p>\n    In the input list, each attribute (<em>attr_name1</em>, <em>attr_name2</em>, etc.) is associated with a list of dictionaries.\n    Each dictionary represents a value entry and contains two keys that should remain as is:\n  </p>\n  <ul>\n    <li><strong>\"value\"</strong>: Specifies the value of the attribute for a specific date.</li>\n    <li><strong>\"date\"</strong>: Specifies the date of the value entry. The date should be in UNIX timestamp format.</li>\n  </ul>\n  <p>\n    The subflow returns an object with keys corresponding to the attribute names specified in the input list, along with their respective weighted averages. The output can be found in <code>msg.payload</code>.\n  </p>\n  <p>\n    It is important to note that the list of dictionaries should be sorted in reverse order based on the date.\n    To achieve this, you can use the quicksort algorithm implemented in another flow, which provides sorting options in either ascending or descending order, based on user preferences.\n  </p>\n</div>\n",
        "category": "",
        "in": [
            {
                "x": 140,
                "y": 180,
                "wires": [
                    {
                        "id": "9442ae94d5fbbe05"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 580,
                "y": 180,
                "wires": [
                    {
                        "id": "9442ae94d5fbbe05",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "9442ae94d5fbbe05",
        "type": "function",
        "z": "0e5ee74342c0495d",
        "name": "Calculate Weighted Average",
        "func": "function calc_weight_avg(list) {\n    // Calculate total weight and weighted sum\n    let totalWeight = 0;\n    let weightedSum = 0;\n\n    list.forEach((temperature, index) => {\n        const weight = index + 1;\n\n        weightedSum += temperature.value * weight;\n        totalWeight += weight;\n    });\n\n    const weightedAverage = weightedSum / totalWeight;\n    return weightedAverage;\n}\n\nconst list = msg.payload.data;\nfor (let key in list) {\n    list[key] = calc_weight_avg(list[key]);\n}\n\nmsg.payload.data = list;\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 180,
        "wires": [
            []
        ]
    },
    {
        "id": "e3362431f3372381",
        "type": "subflow",
        "name": "QuickSort",
        "info": "<div>\n  <p>\n    This is the implementation of the Quick Sort algorithm, which can also perform a reverse sort if desired.\n    To choose reverse sort, put <code>msg.payload.reverse_sort</code> to True, else put it False.\n  </p>\n  <p>\n    It takes as input a list with the following structure (put this in the <code>msg.payload</code>):\n    <code>\n      {\n        \"attr_name1\": [\n          {\"value\": x, \"date\": y},\n          {\"value\": z, \"date\": e}\n        ],\n        \"attr_name2\": [\n          {\"value\": q, \"date\": w},\n          ...\n        ]\n      }\n    </code>\n  </p>\n  <p>\n    In the input list, each attribute (<em>attr_name1</em>, <em>attr_name2</em>, etc.) is associated with a list of dictionaries.\n    Each dictionary represents a value entry and contains two keys that should remain as is:\n  </p>\n  <ul>\n    <li><strong>\"value\"</strong>: Specifies the value of the attribute for a specific date.</li>\n    <li><strong>\"date\"</strong>: Specifies the date of the value entry. The date should be in UNIX timestamp format.</li>\n  </ul>\n  <p>\n    The subflow returns the same structure as the input list, but with the lists of each attribute key sorted either normally or in reverse order, based on the chosen option. The output can be found in <code>msg.payload</code>.\n  </p>\n</div>\n",
        "category": "",
        "in": [
            {
                "x": 140,
                "y": 120,
                "wires": [
                    {
                        "id": "36dec23814efedfb"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 580,
                "y": 120,
                "wires": [
                    {
                        "id": "aa7c06d534637cf0",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "36dec23814efedfb",
        "type": "function",
        "z": "e3362431f3372381",
        "name": "Quick Sort",
        "func": "function quickSort(arr, left, right) {\n    if (left < right) {\n        const pivotIndex = partition(arr, left, right);\n        quickSort(arr, left, pivotIndex - 1);\n        quickSort(arr, pivotIndex + 1, right);\n    }\n    return arr;\n}\n\nfunction partition(arr, left, right) {\n    // const pivot = new Date(arr[right].date);\n    const pivot = arr[right].date;\n    let i = left - 1;\n\n    for (let j = left; j < right; j++) {\n        // const currentDate = new Date(arr[j].date);\n        const currentDate = arr[j].date;\n        if (currentDate < pivot) {\n            i++;\n            swap(arr, i, j);\n        }\n    }\n\n    swap(arr, i + 1, right);\n    return i + 1;\n}\n\nfunction swap(arr, i, j) {\n    const temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\nvar list = msg.payload.data;\nfor (let key in list) {\n    list[key] = quickSort(list[key], 0, list[key].length - 1);\n}\nmsg.payload.data = list;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 120,
        "wires": [
            [
                "aa7c06d534637cf0"
            ]
        ]
    },
    {
        "id": "aa7c06d534637cf0",
        "type": "function",
        "z": "e3362431f3372381",
        "name": "Reverse Sort",
        "func": "// Input: list - array of dictionaries [{ temperature: number, date: string }]\nif (!msg.payload.reverse_sort) {\n    return msg;\n}\n\nvar list = msg.payload.data;\nconsole.log(list);\nfor (let key in list) {\n    list[key] = list[key].reverse();\n}\nmsg.payload.data = list;\nreturn msg;\n\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "b8218229e9c66bfb",
        "type": "subflow",
        "name": "OW monitor",
        "info": "\n\nThis is a subflow node in order to monitor the latest performance (sliding window) of Openwhisk actions. The flow pings periodically the target Openwhisk installation in order to retrieve the last executed actions and extract statistics from their execution.\n\nConfiguration includes:\n - the polling time of the monitor (default 30 seconds, `msg.pollingPeriod`)\n - the target Openwhisk endpoint (`msg.targetEndpoint`)\n - credentials for that endpoint (`msg.creds`) in the form of user:key\n - the window of time (in minutes) in the past for which you want to retrieve results (`msg.window`)\n - an optional action name (`msg.action`), if one wants to filter specific action activations\n\nThe configuration can be set either via the flow UI or the incoming message. The incoming message prevails over the UI-set value.\n\nThe monitor can be stopped via a `msg.stop=true` message. The subflow uses a flow variable in order to control starting and stopping, hence only one OW monitor should be used in each flow.\n\nThe results include the raw data acquired (`msg.payload.rawData`) in the last window of time, as well as the moving averages of duration (`msg.payload.results.movingAverageDuration`), init time (`msg.payload.results.movingAverageInitTime`) and wait time (`msg.payload.results.movingAverageWaitTime`) of the window. The number of cold starts are also included (`msg.payload.results.coldStarts`) as well as the percentage with relation to the total calls (`msg.payload.results.coldStartPercentage`).\n\n\n",
        "category": "PHYSICS PEF",
        "in": [
            {
                "x": 60,
                "y": 80,
                "wires": [
                    {
                        "id": "5b92b00a559c23d6"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 820,
                "y": 180,
                "wires": [
                    {
                        "id": "ae6bc8649fda071b",
                        "port": 0
                    }
                ]
            },
            {
                "x": 560,
                "y": 80,
                "wires": [
                    {
                        "id": "a27743069b5d7075",
                        "port": 0
                    }
                ]
            },
            {
                "x": 1080,
                "y": 320,
                "wires": [
                    {
                        "id": "37dbab2b61f1bbab",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "targetEndpoint",
                "type": "str",
                "value": "http://10.100.59.182:3233/api/v1",
                "ui": {
                    "label": {
                        "en-US": "Target Endpoint"
                    }
                }
            },
            {
                "name": "pollingPeriod",
                "type": "num",
                "value": "30",
                "ui": {
                    "label": {
                        "en-US": "Polling Period (seconds)"
                    }
                }
            },
            {
                "name": "window",
                "type": "num",
                "value": "10",
                "ui": {
                    "label": {
                        "en-US": "Window of Time (minutes)"
                    }
                }
            },
            {
                "name": "namespace",
                "type": "str",
                "value": "guest",
                "ui": {
                    "label": {
                        "en-US": "Namespace"
                    }
                }
            },
            {
                "name": "action",
                "type": "str",
                "value": "",
                "ui": {
                    "label": {
                        "en-US": "Optional Action Name"
                    }
                }
            },
            {
                "name": "creds",
                "type": "cred",
                "ui": {
                    "label": {
                        "en-US": "Credentials (user:key)"
                    }
                }
            }
        ],
        "meta": {
            "module": "node-red-contrib-owmonitor",
            "version": "0.0.1",
            "author": "George Kousiours <gkousiou@hua.gr>",
            "desc": "This is a subflow node in order to monitor the latest performance (sliding window) of Openwhisk actions. The flow pings periodically the target Openwhisk installation in order to retrieve the last executed actions and extract statistics from their execution.",
            "keywords": "openwhisk, performance, monitor, sliding window",
            "license": "Apache-2.0"
        },
        "color": "#E9967A",
        "icon": "node-red/status.svg"
    },
    {
        "id": "1242c9ad8897f17b",
        "type": "http request",
        "z": "b8218229e9c66bfb",
        "name": "",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "df3a306242e21be5",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 290,
        "y": 180,
        "wires": [
            [
                "557c287f0ccd9365"
            ]
        ]
    },
    {
        "id": "5b92b00a559c23d6",
        "type": "function",
        "z": "b8218229e9c66bfb",
        "name": "defaults",
        "func": "if (msg.hasOwnProperty('window')){\n    \n} else {\n    msg.window=env.get('window');\n}\n\nif (msg.hasOwnProperty('targetEndpoint')){\n    \n} else {\n    msg.targetEndpoint=env.get('targetEndpoint');\n}\n\nif (msg.hasOwnProperty('pollingPeriod')){\n    \n} else {\n    msg.pollingPeriod=env.get('pollingPeriod');\n}\n\nif (msg.hasOwnProperty('creds')){\n    \n} else {\n    msg.creds=env.get('creds');\n}\n\nif (msg.hasOwnProperty('namespace')){\n    \n} else {\n    msg.namespace=env.get('namespace');\n}\n\nif (msg.hasOwnProperty('action')){\n    \n} else {\n    msg.action=env.get('action');\n}\n\nif (msg.hasOwnProperty('stop')){\n    flow.set('stop',msg.stop);\n} else {\n    flow.set('stop',false);\n}\n\nmsg.headers={};\nvar auth = 'Basic ' + new Buffer(msg.creds).toString('base64');\nmsg.headers = {\n    \"Authorization\": auth\n}\n\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 180,
        "y": 80,
        "wires": [
            [
                "a27743069b5d7075"
            ]
        ]
    },
    {
        "id": "a27743069b5d7075",
        "type": "function",
        "z": "b8218229e9c66bfb",
        "name": "produce rate",
        "func": "\nfunction sayHi(input) {\n  \n  if (flow.get('stop')) {\n    msg.payload=\"STOPPED\";\n    node.send([msg,null]);\n    clearTimeout(timerId);\n    \n  } else {\n      msg.since=Date.now()-msg.window*60*1000; //remove window of time from timestamp\n      //add since filter\n      msg.url=msg.baseurl+'?since='+msg.since;\n      msg.url=msg.url+'&limit=0';//by default, OW returns 30 results. We need this to return without limit\n      //add optional action name filter. This needs to be second since it may not always exist\n      if (msg.action!==\"\"){\n          msg.url=msg.url+'&name='+msg.action;\n      }\n\n      node.send([null,msg])\n      \n  }\n}\n\nmsg.baseurl=msg.targetEndpoint+'/namespaces/'+msg.namespace+'/activations';\n\nmsg.method='GET';\nvar timerId=setInterval(sayHi, msg.pollingPeriod*1000,msg);\n\n\n",
        "outputs": "2",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 80,
        "wires": [
            [],
            [
                "1242c9ad8897f17b"
            ]
        ]
    },
    {
        "id": "557c287f0ccd9365",
        "type": "function",
        "z": "b8218229e9c66bfb",
        "name": "preprocess results",
        "func": "\n\nvar resultsArray=[];\n\nvar results={};\n\nvar errorsArray=[];\n\nfor (let k=0;k<msg.payload.length;k++){\n    //from OW\n    results.activationId=msg.payload[k].activationId;\n    results.duration=msg.payload[k].duration;\n    results.start=msg.payload[k].start;\n    results.end=msg.payload[k].end;\n    results.action=msg.payload[k].name;\n    results.namespace=msg.payload[k].namespace;\n    results.statusCode=msg.payload[k].statusCode;\n    results.version=msg.payload[k].version;\n    \n    if (msg.payload[k].statusCode!=0){\n        errorsArray.push(msg.payload[k].activationId);\n    }\n    \n    //results.success=msg.payload[k].response.success; This is not included in the summary results\n    for (let i=0;i<msg.payload[k].annotations.length;i++){\n        if (msg.payload[k].annotations[i].key==='waitTime'){\n            results.waitTime=msg.payload[k].annotations[i].value;\n        }\n        if (msg.payload[k].annotations[i].key==='initTime'){\n            results.initTime=msg.payload[k].annotations[i].value;\n        }\n        \n    }\n    \n    if (!(results.hasOwnProperty('initTime'))){\n        results.initTime=0;\n    }\n    if (msg.action===\"\"){\n        resultsArray.push(results);    \n    } else {\n        if (results.action===msg.action){\n            resultsArray.push(results);\n        }\n    }\n    \n    // @ts-ignore\n    results={};\n    \n}    \nmsg.payload={};\nmsg.payload=resultsArray;\nmsg.errors=errorsArray;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 180,
        "wires": [
            [
                "ae6bc8649fda071b",
                "71732c27b0fcedd6"
            ]
        ]
    },
    {
        "id": "ae6bc8649fda071b",
        "type": "function",
        "z": "b8218229e9c66bfb",
        "name": "averages",
        "func": "var rawData=msg.payload;\nmsg.payload={};\nmsg.payload.rawData=rawData;\nvar samples=msg.payload.rawData.length;\n\nmsg.results={};\nmsg.results.averageDuration=0;\nmsg.results.averageWaitTime=0;\nmsg.results.averageInitTime=0;\nmsg.results.coldStarts=0;\nmsg.results.successPercentage=0;\n\nvar duration= [];//=new Array();\nvar waitTime=[];\nvar initTime=[];\n\n\nfor (i=0;i<msg.payload.rawData.length;i++){\n    msg.results.averageDuration=msg.results.averageDuration+msg.payload.rawData[i].duration;\n    duration.push(msg.payload.rawData[i].duration);\n    \n    msg.results.averageWaitTime=msg.results.averageWaitTime+msg.payload.rawData[i].waitTime;\n    waitTime.push(msg.payload.rawData[i].waitTime);\n    \n    msg.results.averageInitTime=msg.results.averageInitTime+msg.payload.rawData[i].initTime;\n    initTime.push(msg.payload.rawData[i].initTime);\n    if (msg.payload.rawData[i].initTime!==0){\n        msg.results.coldStarts=msg.results.coldStarts+1;\n    }\n    if (msg.payload.rawData[i].statusCode===0){\n        msg.results.successPercentage=msg.results.successPercentage+1;\n    }\n    \n\n}\nmsg.results.successPercentage=(msg.results.successPercentage/msg.payload.rawData.length)*100;\nmsg.results.averageDuration=toFixedNumber(msg.results.averageDuration/samples,2);\nmsg.results.averageWaitTime=toFixedNumber(msg.results.averageWaitTime/samples,2);\nmsg.results.averageInitTime=toFixedNumber(msg.results.averageInitTime/samples,2);\nmsg.results.coldStartPercentage=toFixedNumber((msg.results.coldStarts/samples)*100,2);\n\nmsg.results.movingAverageDuration=msg.results.averageDuration;\ndelete msg.results.averageDuration;\n\nmsg.results.movingAverageWaitTime=msg.results.averageWaitTime;\ndelete msg.results.averageWaitTime;\n\nmsg.results.movingAverageInitTime=msg.results.averageInitTime;\ndelete msg.results.averageInitTime;\n\n\nmsg.payload.results=msg.results;\nreturn msg;\n\n\nfunction toFixedNumber(num, digits, base){\n  var pow = Math.pow(base||10, digits);\n  return Math.round(num*pow) / pow;\n}\n",
        "outputs": 1,
        "noerr": 14,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 180,
        "wires": [
            []
        ]
    },
    {
        "id": "45a102851f96a251",
        "type": "split",
        "z": "b8218229e9c66bfb",
        "name": "",
        "splt": "\\n",
        "spltType": "str",
        "arraySplt": 1,
        "arraySpltType": "len",
        "stream": false,
        "addname": "",
        "x": 370,
        "y": 320,
        "wires": [
            [
                "f9e10aaf7b5646cd"
            ]
        ]
    },
    {
        "id": "71732c27b0fcedd6",
        "type": "change",
        "z": "b8218229e9c66bfb",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "errors",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 220,
        "y": 320,
        "wires": [
            [
                "45a102851f96a251"
            ]
        ]
    },
    {
        "id": "f9e10aaf7b5646cd",
        "type": "function",
        "z": "b8218229e9c66bfb",
        "name": "prepare call",
        "func": "msg.url=msg.targetEndpoint+'/namespaces/'+msg.namespace+'/activations/'+msg.payload;\nmsg.method='GET';\nmsg.headers={};\nvar auth = 'Basic ' + new Buffer(msg.creds).toString('base64');\nmsg.headers = {\n    \"Authorization\": auth\n}\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 320,
        "wires": [
            [
                "25c20334076b73d8"
            ]
        ]
    },
    {
        "id": "25c20334076b73d8",
        "type": "http request",
        "z": "b8218229e9c66bfb",
        "name": "",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "df3a306242e21be5",
        "persist": false,
        "proxy": "",
        "authType": "",
        "x": 670,
        "y": 320,
        "wires": [
            [
                "6d96c447431b26d6"
            ]
        ]
    },
    {
        "id": "37dbab2b61f1bbab",
        "type": "join",
        "z": "b8218229e9c66bfb",
        "name": "",
        "mode": "auto",
        "build": "object",
        "property": "payload",
        "propertyType": "msg",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "accumulate": "false",
        "timeout": "",
        "count": "",
        "reduceRight": false,
        "x": 970,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "6d96c447431b26d6",
        "type": "function",
        "z": "b8218229e9c66bfb",
        "name": "logs string",
        "func": "msg.payload.logs=msg.payload.logs.join('\\r\\n');\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 830,
        "y": 320,
        "wires": [
            [
                "37dbab2b61f1bbab"
            ]
        ]
    },
    {
        "id": "c3d374152463b5bd",
        "type": "comment",
        "z": "b8218229e9c66bfb",
        "name": "STOP",
        "info": "",
        "x": 650,
        "y": 80,
        "wires": []
    },
    {
        "id": "ba21921f45a01e58",
        "type": "comment",
        "z": "b8218229e9c66bfb",
        "name": "PERFORMANCE STATISTICS",
        "info": "",
        "x": 990,
        "y": 180,
        "wires": []
    },
    {
        "id": "9001e0a07df5442d",
        "type": "comment",
        "z": "b8218229e9c66bfb",
        "name": "ERROR LOGS",
        "info": "",
        "x": 1000,
        "y": 360,
        "wires": []
    },
    {
        "id": "df3a306242e21be5",
        "type": "tls-config",
        "name": "",
        "cert": "",
        "key": "",
        "ca": "",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "",
        "verifyservercert": false,
        "alpnprotocol": ""
    },
    {
        "id": "31ed873d528182e4",
        "type": "tab",
        "label": "CommonFunctions",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "47ee0f0c3bbc3db0",
        "type": "http in",
        "z": "31ed873d528182e4",
        "name": "",
        "url": "/run",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 240,
        "y": 400,
        "wires": [
            [
                "1544300e49e3b264"
            ]
        ]
    },
    {
        "id": "953b89559a24b92f",
        "type": "http response",
        "z": "31ed873d528182e4",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 950,
        "y": 400,
        "wires": []
    },
    {
        "id": "cac94c8acd92ac59",
        "type": "debug",
        "z": "31ed873d528182e4",
        "name": "debug 59",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 300,
        "wires": []
    },
    {
        "id": "8510a3fd1559f3c2",
        "type": "function",
        "z": "31ed873d528182e4",
        "name": "Clustering function",
        "func": "const clusterMaker = global.get('clusters');\nvar centroids = [];\nclusterMaker.k(3);\nclusterMaker.iterations(750)\n\nif (msg.payload.value.mode === \"multiple\"){\n    \n    //for each resource\n    msg.payload.value.data.forEach( element => {\n        \n        //creating clusterMakerInput\n        let clusterMakerInput = [];\n        element.value.forEach( value => {\n            clusterMakerInput.push([value])\n        });\n        \n        clusterMaker.data(clusterMakerInput);\n        \n        let temp = clusterMaker.clusters();\n        \n        //creating the output \n        let clusterMakerOutput = [];\n        temp.forEach( element => {\n            element.centroid.forEach(element2 => {\n                clusterMakerOutput.push(element2)\n            });\n        });\n        clusterMakerOutput.sort()\n        centroids.push({ [element.name]: clusterMakerOutput});\n    });\n} else if (msg.payload.value.mode === \"single\") {\n\n    //data.length = m\n    //data.element1.lenght = n\n    //finding the max length of all data arrays\n    let temp = [];\n    let n = [];\n\n    for (let m = 0; m < msg.payload.value.data.length;m++){\n        n.push(msg.payload.value.data[m].value.length)\n    }\n\n    const nMax = Math.max(...n);\n\n    //creating the array for clusterMakerInput\n    let clusterMakerInput = []; \n    for (let n = 0; n < nMax; n++) {\n        let arrTemp = [];\n        msg.payload.value.data.forEach( m => {\n\n            arrTemp.push(m.value[n]);\n\n        });\n        clusterMakerInput.push(arrTemp);\n    }\n    console.log(clusterMakerInput);\n    clusterMaker.data(clusterMakerInput);\n    centroids = clusterMaker.clusters();\n\n}\nmsg.payload = {centroids};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "8e30fbc04dc53594",
        "type": "http in",
        "z": "31ed873d528182e4",
        "name": "",
        "url": "/init",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 360,
        "y": 620,
        "wires": [
            [
                "efed09a296a31c8a"
            ]
        ]
    },
    {
        "id": "efed09a296a31c8a",
        "type": "http response",
        "z": "31ed873d528182e4",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 550,
        "y": 620,
        "wires": []
    },
    {
        "id": "db3c434476868783",
        "type": "catch",
        "z": "31ed873d528182e4",
        "name": "",
        "scope": null,
        "uncaught": false,
        "x": 360,
        "y": 540,
        "wires": [
            [
                "ed3cb16fc8bb0d6a"
            ]
        ]
    },
    {
        "id": "ed3cb16fc8bb0d6a",
        "type": "function",
        "z": "31ed873d528182e4",
        "name": "ADD ERROR INFO",
        "func": "var payload=msg.payload;\nmsg.payload={};\n\nmsg.payload.error=msg.error;\nmsg.payload.error.payload=payload;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 560,
        "wires": [
            [
                "953b89559a24b92f"
            ]
        ]
    },
    {
        "id": "b017de6d7936f746",
        "type": "subflow:b8218229e9c66bfb",
        "z": "31ed873d528182e4",
        "name": "",
        "x": 270,
        "y": 120,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "b4dd51095688d3fb",
        "type": "subflow:e3362431f3372381",
        "z": "31ed873d528182e4",
        "name": "",
        "x": 540,
        "y": 400,
        "wires": [
            [
                "953b89559a24b92f",
                "cac94c8acd92ac59"
            ]
        ]
    },
    {
        "id": "1544300e49e3b264",
        "type": "switch",
        "z": "31ed873d528182e4",
        "name": "",
        "property": "payload.function",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "kmeans",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "quicksort",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "wavg",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 390,
        "y": 400,
        "wires": [
            [
                "a7b5cc53f81bcfb1"
            ],
            [
                "b4dd51095688d3fb"
            ],
            [
                "938a0f1e1f1e4844"
            ]
        ]
    },
    {
        "id": "938a0f1e1f1e4844",
        "type": "subflow:0e5ee74342c0495d",
        "z": "31ed873d528182e4",
        "name": "",
        "x": 580,
        "y": 500,
        "wires": [
            [
                "953b89559a24b92f",
                "cac94c8acd92ac59"
            ]
        ]
    },
    {
        "id": "a7b5cc53f81bcfb1",
        "type": "function",
        "z": "31ed873d528182e4",
        "name": "Clustering function",
        "func": "const clusterMaker = global.get('clusters');\nvar centroids = [];\nclusterMaker.k(3);\nclusterMaker.iterations(750)\n\nif (msg.payload.value.mode === \"multiple\"){\n    \n    //for each resource\n    msg.payload.value.data.forEach( element => {\n        \n        //creating clusterMakerInput\n        let clusterMakerInput = [];\n        element.value.forEach( value => {\n            clusterMakerInput.push([value])\n        });\n        \n        clusterMaker.data(clusterMakerInput);\n        \n        let temp = clusterMaker.clusters();\n        \n        //creating the output \n        let clusterMakerOutput = [];\n        temp.forEach( element => {\n            element.centroid.forEach(element2 => {\n                clusterMakerOutput.push(element2)\n            });\n        });\n        clusterMakerOutput.sort()\n        centroids.push({ [element.name]: clusterMakerOutput});\n    });\n} else if (msg.payload.value.mode === \"single\") {\n\n    //data.length = m\n    //data.element1.lenght = n\n    //finding the max length of all data arrays\n    let temp = [];\n    let n = [];\n\n    for (let m = 0; m < msg.payload.value.data.length;m++){\n        n.push(msg.payload.value.data[m].value.length)\n    }\n\n    const nMax = Math.max(...n);\n\n    //creating the array for clusterMakerInput\n    let clusterMakerInput = []; \n    for (let n = 0; n < nMax; n++) {\n        let arrTemp = [];\n        msg.payload.value.data.forEach( m => {\n\n            arrTemp.push(m.value[n]);\n\n        });\n        clusterMakerInput.push(arrTemp);\n    }\n    console.log(clusterMakerInput);\n    clusterMaker.data(clusterMakerInput);\n    centroids = clusterMaker.clusters();\n\n}\nmsg.payload = {centroids};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 280,
        "wires": [
            [
                "953b89559a24b92f",
                "cac94c8acd92ac59"
            ]
        ]
    }
]
