[
    {
        "id": "5f294e422cb57a8d",
        "type": "subflow",
        "name": "Calculate Weighted Average",
        "info": "<div>\n  <p>\n    This subflow calculates the weighted average of given values, considering the date of each value.\n    The more recent the date, the higher the value will be weighted in the average calculation.\n  </p>\n  <p>\n    It takes as input a list with the following structure (put this in the <code>msg.payload.data</code>):\n    <code>\n      {\n        \"attr_name1\": [\n          {\"value\": x, \"date\": y},\n          {\"value\": z, \"date\": e}\n        ],\n        \"attr_name2\": [\n          {\"value\": q, \"date\": w},\n          ...\n        ]\n      }\n    </code>\n  </p>\n  <p>\n    In the input list, each attribute (<em>attr_name1</em>, <em>attr_name2</em>, etc.) is associated with a list of dictionaries.\n    Each dictionary represents a value entry and contains two keys that should remain as is:\n  </p>\n  <ul>\n    <li><strong>\"value\"</strong>: Specifies the value of the attribute for a specific date.</li>\n    <li><strong>\"date\"</strong>: Specifies the date of the value entry. The date should be in UNIX timestamp format.</li>\n  </ul>\n  <p>\n    The subflow returns an object with keys corresponding to the attribute names specified in the input list, along with their respective weighted averages. The output can be found in <code>msg.payload.data</code>.\n  </p>\n  <p>\n    It is important to note that the list of dictionaries should be sorted in reverse order based on the date.\n    To achieve this, you can use the quicksort algorithm implemented in another flow, which provides sorting options in either ascending or descending order, based on user preferences.\n  </p>\n</div>\n",
        "category": "",
        "in": [
            {
                "x": 140,
                "y": 180,
                "wires": [
                    {
                        "id": "4d0a70163a88c0dd"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 580,
                "y": 180,
                "wires": [
                    {
                        "id": "4d0a70163a88c0dd",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "4d0a70163a88c0dd",
        "type": "function",
        "z": "5f294e422cb57a8d",
        "name": "Calculate Weighted Average",
        "func": "function calc_weight_avg(list) {\n    // Calculate total weight and weighted sum\n    let totalWeight = 0;\n    let weightedSum = 0;\n\n    list.forEach((temperature, index) => {\n        const weight = index + 1;\n\n        weightedSum += temperature.value * weight;\n        totalWeight += weight;\n    });\n\n    const weightedAverage = weightedSum / totalWeight;\n    return weightedAverage;\n}\n\nconst list = msg.payload.data;\nfor (let key in list) {\n    list[key] = calc_weight_avg(list[key]);\n}\n\nmsg.payload.data = list;\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 180,
        "wires": [
            []
        ]
    },
    {
        "id": "a833c5f1efa92886",
        "type": "subflow",
        "name": "Weighted Average Req Docker",
        "info": "<div>\n  <p>\n    This subflow communicates with a Docker container running on your PC and runs the Weighted Average Common Function.\n    It uses the Docker image available on Docker Hub:\n    <a href=\"https://hub.docker.com/r/kazakos13/common-functions\">kazakos13/common-functions</a>.\n    If the Docker endpoint is not available, it falls back to running the local build of the Weighted Average subflow.\n  </p>\n  <h3>Input Structure</h3>\n  <p>\n    The subflow takes as input a list with the following structure, which should be placed in the <code>msg.payload.data</code> property:\n  </p>\n  <pre>\n    <code>\n{\n  \"attr_name1\": [\n    {\"value\": x, \"date\": y},\n    {\"value\": z, \"date\": e}\n  ],\n  \"attr_name2\": [\n    {\"value\": q, \"date\": w},\n    ...\n  ]\n}\n    </code>\n  </pre>\n  <p>\n    In the input list, each attribute (<em>attr_name1</em>, <em>attr_name2</em>, etc.) is associated with a list of dictionaries.\n    Each dictionary represents a value entry and contains two keys that should remain as is:\n  </p>\n  <ul>\n    <li><strong>\"value\"</strong>: Specifies the value of the attribute for a specific date.</li>\n    <li><strong>\"date\"</strong>: Specifies the date of the value entry. The date should be in UNIX timestamp format.</li>\n  </ul>\n  <h3>Output Structure</h3>\n  <p>\n    The subflow returns an object with keys corresponding to the attribute names specified in the input list, along with their respective weighted averages. The output can be found in the <code>msg.payload.data</code> property.\n  </p>\n  <p>\n    It is important to note that the list of dictionaries should be sorted in reverse order based on the date.\n    To achieve this, you can use the Quicksort algorithm implemented in another flow, which provides sorting options in either ascending or descending order, based on user preferences.\n  </p>\n</div>\n",
        "category": "",
        "in": [
            {
                "x": 40,
                "y": 80,
                "wires": [
                    {
                        "id": "428194049d20af93"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 840,
                "y": 140,
                "wires": [
                    {
                        "id": "0f077dbe1e98e210",
                        "port": 0
                    },
                    {
                        "id": "7406314592d9e8cb",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#E2D96E"
    },
    {
        "id": "428194049d20af93",
        "type": "change",
        "z": "a833c5f1efa92886",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "copy_input",
                "pt": "msg",
                "to": "payload",
                "tot": "msg",
                "dc": true
            },
            {
                "t": "set",
                "p": "payload.function",
                "pt": "msg",
                "to": "wavg",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 200,
        "y": 80,
        "wires": [
            [
                "8c7228e2f5cf8f0e"
            ]
        ]
    },
    {
        "id": "8c7228e2f5cf8f0e",
        "type": "http request",
        "z": "a833c5f1efa92886",
        "name": "Weight Avg Docker",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://127.0.0.1:8080/run",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 290,
        "y": 160,
        "wires": [
            [
                "0f077dbe1e98e210"
            ]
        ]
    },
    {
        "id": "0f077dbe1e98e210",
        "type": "function",
        "z": "a833c5f1efa92886",
        "name": "Error Handler",
        "func": "if (msg.statusCode != 200) {\n    msg.payload = msg.copy_input;\n    return [null,msg];\n}\nreturn[msg,null];",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 240,
        "wires": [
            [],
            [
                "006c55d0127faa6a",
                "7406314592d9e8cb"
            ]
        ]
    },
    {
        "id": "7406314592d9e8cb",
        "type": "subflow:5f294e422cb57a8d",
        "z": "a833c5f1efa92886",
        "name": "",
        "x": 720,
        "y": 240,
        "wires": [
            []
        ]
    },
    {
        "id": "006c55d0127faa6a",
        "type": "debug",
        "z": "a833c5f1efa92886",
        "name": "Error Docker Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "\"Could not find docker quicksort algorithm. Executing local quicksort subflow.\"",
        "targetType": "jsonata",
        "statusVal": "",
        "statusType": "auto",
        "x": 640,
        "y": 300,
        "wires": []
    },
    {
        "id": "6fd479bb119a914b",
        "type": "subflow",
        "name": "QuickSort",
        "info": "<div>\n  <p>\n    This is the implementation of the Quick Sort algorithm, which can also perform a reverse sort if desired.\n    To choose reverse sort, put <code>msg.payload.reverse_sort</code> to True, else put it False.\n  </p>\n  <p>\n    It takes as input a list with the following structure (put this in the <code>msg.payload.data</code>):\n    <code>\n      {\n        \"attr_name1\": [\n          {\"value\": x, \"date\": y},\n          {\"value\": z, \"date\": e}\n        ],\n        \"attr_name2\": [\n          {\"value\": q, \"date\": w},\n          ...\n        ]\n      }\n    </code>\n  </p>\n  <p>\n    In the input list, each attribute (<em>attr_name1</em>, <em>attr_name2</em>, etc.) is associated with a list of dictionaries.\n    Each dictionary represents a value entry and contains two keys that should remain as is:\n  </p>\n  <ul>\n    <li><strong>\"value\"</strong>: Specifies the value of the attribute for a specific date.</li>\n    <li><strong>\"date\"</strong>: Specifies the date of the value entry. The date should be in UNIX timestamp format.</li>\n  </ul>\n  <p>\n    The subflow returns the same structure as the input list, but with the lists of each attribute key sorted either normally or in reverse order, based on the chosen option. The output can be found in <code>msg.payload.data</code>.\n  </p>\n</div>\n",
        "category": "",
        "in": [
            {
                "x": 140,
                "y": 120,
                "wires": [
                    {
                        "id": "8a975444807b5c68"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 580,
                "y": 120,
                "wires": [
                    {
                        "id": "6fef86d08511923a",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "8a975444807b5c68",
        "type": "function",
        "z": "6fd479bb119a914b",
        "name": "Quick Sort",
        "func": "function quickSort(arr, left, right) {\n    if (left < right) {\n        const pivotIndex = partition(arr, left, right);\n        quickSort(arr, left, pivotIndex - 1);\n        quickSort(arr, pivotIndex + 1, right);\n    }\n    return arr;\n}\n\nfunction partition(arr, left, right) {\n    // const pivot = new Date(arr[right].date);\n    const pivot = arr[right].date;\n    let i = left - 1;\n\n    for (let j = left; j < right; j++) {\n        // const currentDate = new Date(arr[j].date);\n        const currentDate = arr[j].date;\n        if (currentDate < pivot) {\n            i++;\n            swap(arr, i, j);\n        }\n    }\n\n    swap(arr, i + 1, right);\n    return i + 1;\n}\n\nfunction swap(arr, i, j) {\n    const temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\nvar list = msg.payload.data;\nfor (let key in list) {\n    list[key] = quickSort(list[key], 0, list[key].length - 1);\n}\nmsg.payload.data = list;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 120,
        "wires": [
            [
                "6fef86d08511923a"
            ]
        ]
    },
    {
        "id": "6fef86d08511923a",
        "type": "function",
        "z": "6fd479bb119a914b",
        "name": "Reverse Sort",
        "func": "// Input: list - array of dictionaries [{ temperature: number, date: string }]\nif (!msg.payload.reverse_sort) {\n    return msg;\n}\n\nvar list = msg.payload.data;\nconsole.log(list);\nfor (let key in list) {\n    list[key] = list[key].reverse();\n}\nmsg.payload.data = list;\nreturn msg;\n\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "668a9e3b55094c55",
        "type": "subflow",
        "name": "QuickSort Req Docker",
        "info": "<div>\n  <p>\n    This subflow communicates with a Docker container running on your PC  and runs the QuickSort Algorithm (user can also get the reverse result - put <code>msg.payload.reverse_sort = True</code>). It uses the Docker image available on Docker Hub:\n    <a href=\"https://hub.docker.com/r/kazakos13/common-functions\">kazakos13/common-functions</a>.\n    If the Docker endpoint is not available, it falls back to running the local build of the Quicksort subflow.\n  </p>\n  <h3>Input Structure</h3>\n  <p>\n    The subflow takes as input a list with the following structure, which should be placed in the <code>msg.payload.data</code> property:\n  </p>\n  <pre>\n    <code>\n{\n  \"attr_name1\": [\n    {\"value\": x, \"date\": y},\n    {\"value\": z, \"date\": e}\n  ],\n  \"attr_name2\": [\n    {\"value\": q, \"date\": w},\n    ...\n  ]\n}\n    </code>\n  </pre>\n  <p>\n    In the input list, each attribute (<em>attr_name1</em>, <em>attr_name2</em>, etc.) is associated with a list of dictionaries.\n    Each dictionary represents a value entry and contains two keys that should remain as is:\n  </p>\n  <ul>\n    <li><strong>\"value\"</strong>: Specifies the value of the attribute for a specific date.</li>\n    <li><strong>\"date\"</strong>: Specifies the date of the value entry. The date should be in UNIX timestamp format.</li>\n  </ul>\n  <h3>Output Structure</h3>\n  <p>\n    The subflow returns the same structure as the input list, but with the lists of each attribute key sorted either in normal order or in reverse order, based on the chosen option. The output can be found in the <code>msg.payload.data</code> property.\n  </p>\n</div>\n",
        "category": "",
        "in": [
            {
                "x": 20,
                "y": 80,
                "wires": [
                    {
                        "id": "296d26534dff0291"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 880,
                "y": 80,
                "wires": [
                    {
                        "id": "12b6c9f8293ef70e",
                        "port": 0
                    },
                    {
                        "id": "b67072cd46aba415",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#E2D96E"
    },
    {
        "id": "296d26534dff0291",
        "type": "change",
        "z": "668a9e3b55094c55",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "copy_input",
                "pt": "msg",
                "to": "payload",
                "tot": "msg",
                "dc": true
            },
            {
                "t": "set",
                "p": "payload.function",
                "pt": "msg",
                "to": "quicksort",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 180,
        "y": 80,
        "wires": [
            [
                "3eef448fa0ef8d0e"
            ]
        ]
    },
    {
        "id": "3eef448fa0ef8d0e",
        "type": "http request",
        "z": "668a9e3b55094c55",
        "name": "Quicksort Docker",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://127.0.0.1:8080/run",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 410,
        "y": 80,
        "wires": [
            [
                "b67072cd46aba415"
            ]
        ]
    },
    {
        "id": "b67072cd46aba415",
        "type": "function",
        "z": "668a9e3b55094c55",
        "name": "Error Handler",
        "func": "if (msg.statusCode != 200) {\n    msg.payload = msg.copy_input;\n    return [null,msg];\n}\nreturn[msg,null];",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 160,
        "wires": [
            [],
            [
                "12b6c9f8293ef70e",
                "303eebea317b6d0d"
            ]
        ]
    },
    {
        "id": "303eebea317b6d0d",
        "type": "debug",
        "z": "668a9e3b55094c55",
        "name": "Error Docker Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "\"Could not find docker quicksort algorithm. Executing local quicksort subflow.\"",
        "targetType": "jsonata",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 220,
        "wires": []
    },
    {
        "id": "12b6c9f8293ef70e",
        "type": "subflow:6fd479bb119a914b",
        "z": "668a9e3b55094c55",
        "name": "",
        "x": 760,
        "y": 160,
        "wires": [
            []
        ]
    },
    {
        "id": "1c1d09cb50197133",
        "type": "subflow",
        "name": "Get Many Weather API Data",
        "info": "<div>\n  <p>\n    This subflow calculates the weighted averages of weather information from multiple weather APIs to provide a more precise estimation of the current weather condition.\n  </p>\n  <p>\n    It takes as input the latitude and longitude coordinates (as floats) specified in the <code>msg.city.lat</code> and <code>msg.city.lng</code> properties.\n    Additionally, you need to provide the API keys for the following weather APIs:\n  </p>\n  <ul>\n    <li>\n      <strong>OpenWeatherMap:</strong>\n      <a href=\"https://openweathermap.org/current\" target=\"_blank\">OpenWeatherMap API</a>\n      - Specify the API key in <code>msg.openweathermapapi_key</code>.\n    </li>\n    <li>\n      <strong>Tomorrow API:</strong>\n      <a href=\"https://docs.tomorrow.io/reference/welcome\" target=\"_blank\">Tomorrow API</a>\n      - Specify the API key in <code>msg.tomorrowapi_key</code>.\n    </li>\n    <li>\n      <strong>WeatherAPI:</strong>\n      <a href=\"https://www.weatherapi.com/docs/\" target=\"_blank\">WeatherAPI</a>\n      - Specify the API key in <code>msg.weatherapi_key</code>.\n    </li>\n  </ul>\n  <p>\n    Note that the <a href=\"https://open-meteo.com/en/docs\" target=\"_blank\">OpenMeteo API</a> is also used, but it does not require an API key.\n  </p>\n  <p>\n    The output can be found in <code>msg.payload</code> and it is an object similar to the response from OpenWeatherMap API, but with the values changed to the average weighted values calculated from all the previous APIs.\n  </p>\n</div>\n",
        "category": "",
        "in": [
            {
                "x": 80,
                "y": 60,
                "wires": [
                    {
                        "id": "f1ae844bf041de78"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 2140,
                "y": 120,
                "wires": [
                    {
                        "id": "445ca5f07bd03145",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "870258360fc34f6f",
        "type": "http request",
        "z": "1c1d09cb50197133",
        "name": "",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 410,
        "y": 140,
        "wires": [
            [
                "7f921967cd011a07"
            ]
        ]
    },
    {
        "id": "f5e296816b0a808e",
        "type": "function",
        "z": "1c1d09cb50197133",
        "name": "Weather APIs",
        "func": "var lat = msg.city.lat;\nvar lng = msg.city.lng;\nflow.set(\"lat\", lat);\nflow.set(\"lng\", lng);\nvar weatherapi_key = msg.weatherapi_key;\nvar openweathermapapi_key = msg.openweathermapapi_key;\nvar tommorowapi_key = msg.tommorowapi_key;\nvar weatherapi = {topic:\"weatherapi\", url:`http://api.weatherapi.com/v1/current.json?key=${weatherapi_key}&q=${lat},${lng}&aqi=no`}\nvar openweather = { topic: \"openweather\",url: `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lng}&appid=${openweathermapapi_key}&units=metric`}\nvar tommorowapi = { topic: \"tommorowapi\",url: `https://api.tomorrow.io/v4/weather/realtime?location=${lat},${lng}&apikey=${tommorowapi_key}`}\nvar openmeteoapi = { topic: \"openmeteoapi\", url: `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current_weather=true&hourly=temperature_2m,relativehumidity_2m,surface_pressure,cloudcover,visibility&forecast_days=1`}\nreturn [weatherapi, openweather, tommorowapi, openmeteoapi];",
        "outputs": 4,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 200,
        "y": 200,
        "wires": [
            [
                "870258360fc34f6f"
            ],
            [
                "23da8d707aaaceef"
            ],
            [
                "3fa7c5a192c04673"
            ],
            [
                "fcbaf5c82897ce0b"
            ]
        ]
    },
    {
        "id": "23da8d707aaaceef",
        "type": "http request",
        "z": "1c1d09cb50197133",
        "name": "",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 410,
        "y": 180,
        "wires": [
            [
                "7f921967cd011a07"
            ]
        ]
    },
    {
        "id": "3fa7c5a192c04673",
        "type": "http request",
        "z": "1c1d09cb50197133",
        "name": "",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 410,
        "y": 220,
        "wires": [
            [
                "7f921967cd011a07"
            ]
        ]
    },
    {
        "id": "fcbaf5c82897ce0b",
        "type": "http request",
        "z": "1c1d09cb50197133",
        "name": "",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 410,
        "y": 260,
        "wires": [
            [
                "7f921967cd011a07"
            ]
        ]
    },
    {
        "id": "7f921967cd011a07",
        "type": "join",
        "z": "1c1d09cb50197133",
        "name": "",
        "mode": "custom",
        "build": "object",
        "property": "payload",
        "propertyType": "msg",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "accumulate": false,
        "timeout": "",
        "count": "4",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 590,
        "y": 200,
        "wires": [
            [
                "f343866b392379ef",
                "fa70787883fe9b16",
                "f0b3237d262551ce",
                "d10e44f3bcdfb9f5",
                "aee8abb6d40c18b4",
                "0b21169bf4a24a6f",
                "c1d8d69c093a01f1",
                "0c475f2f2b341f84",
                "5d34355f66dfb6a5"
            ]
        ]
    },
    {
        "id": "f343866b392379ef",
        "type": "debug",
        "z": "1c1d09cb50197133",
        "name": "debug 60",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 740,
        "y": 80,
        "wires": []
    },
    {
        "id": "fa70787883fe9b16",
        "type": "function",
        "z": "1c1d09cb50197133",
        "name": "Make list of temps & dates",
        "func": "var weatherapi_dict = {};\nvar openmeteoapi_dict = {};\nvar tommorowapi_dict = {};\nvar openweatherapi_dict = {};\nvar missing_keys = [];\nif (!msg.payload['weatherapi']['error']) {\n    weatherapi_dict = { \"date\": msg.payload['weatherapi']['current']['last_updated_epoch'] * 1000, \"value\": msg.payload['weatherapi']['current']['temp_c'] };\n} else {\n    missing_keys.push(\"weatherapi\");\n}\nif (!msg.payload['tommorowapi']['code']) {\n    tommorowapi_dict = { \"date\": Date.parse(msg.payload['tommorowapi']['data']['time']), \"value\": msg.payload['tommorowapi']['data']['values']['temperature'] };\n} else {\n    missing_keys.push(\"tommorowapi\");\n}\nif (msg.payload['openweather']['cod'] == 200) {\n    openweatherapi_dict = { \"date\": msg.payload['openweather']['dt'] * 1000, \"value\": msg.payload['openweather']['main']['temp'] };\n} else {\n    missing_keys.push(\"openweatherapi\");\n}\nopenmeteoapi_dict = { \"date\": Date.parse(msg.payload['openmeteoapi']['current_weather']['time']), \"value\": msg.payload['openmeteoapi']['current_weather']['temperature'] };\nmsg.payload = [weatherapi_dict, openmeteoapi_dict, openweatherapi_dict, tommorowapi_dict];\nmsg.missing_keys = missing_keys;\nmsg.topic = \"temperature\";\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 240,
        "wires": [
            [
                "8fce24e929f52d06"
            ]
        ]
    },
    {
        "id": "f0b3237d262551ce",
        "type": "function",
        "z": "1c1d09cb50197133",
        "name": "Make list of windsp & dates",
        "func": "// wind speed is meters per second.\nvar weatherapi_dict = {};\nvar openmeteoapi_dict = {};\nvar tommorowapi_dict = {};\nvar openweatherapi_dict = {};\nvar missing_keys= [];\nif (!msg.payload['weatherapi']['error']) {\n    weatherapi_dict = { \"date\": msg.payload['weatherapi']['current']['last_updated_epoch'] * 1000, \"value\": msg.payload['weatherapi']['current']['wind_kph'] * 0.2778 };\n} else {\n    missing_keys.push(\"weatherapi\");\n}\nif (!msg.payload['tommorowapi']['code']) {\n    tommorowapi_dict = { \"date\": Date.parse(msg.payload['tommorowapi']['data']['time']), \"value\": msg.payload['tommorowapi']['data']['values']['windSpeed'] };\n} else {\n    missing_keys.push(\"tommorowapi\");\n}\nif (msg.payload['openweather']['cod'] == 200) {\n    openweatherapi_dict = { \"date\": msg.payload['openweather']['dt'] * 1000, \"value\": msg.payload['openweather']['wind']['speed'] };\n} else {\n    missing_keys.push(\"openweatherapi\");\n}\nopenmeteoapi_dict = { \"date\": Date.parse(msg.payload['openmeteoapi']['current_weather']['time']), \"value\": msg.payload['openmeteoapi']['current_weather']['windspeed'] * 0.2778 };\nmsg.payload = [weatherapi_dict, openmeteoapi_dict, openweatherapi_dict, tommorowapi_dict];\nmsg.missing_keys = missing_keys;\nmsg.topic = \"wind_speed\";\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 280,
        "wires": [
            [
                "8fce24e929f52d06"
            ]
        ]
    },
    {
        "id": "d10e44f3bcdfb9f5",
        "type": "function",
        "z": "1c1d09cb50197133",
        "name": "Make list of pressure & dates",
        "func": "// wind speed is meters per second.\nconst currentTimestamp = Date.now();\nconst time_of_day = msg.payload['openmeteoapi']['hourly']['time'];\nvar latest_time = 0;\n// console.log(currentTimestamp);\nvar index = 0;\nfor(var time of time_of_day){\n    const time_ml = Date.parse(time);    // converts seconds to miliseconds.\n    if (time_ml <= currentTimestamp){\n        latest_time = time_ml;\n        index += 1;\n        console.log(latest_time);\n    } else {\n        break;\n    }\n}\nindex -= 1;\n// msg.payload = latest_time;\n\nvar weatherapi_dict = {};\nvar tommorowapi_dict = {};\nvar openweatherapi_dict = {};\nvar missing_keys = [];\nif (!msg.payload['weatherapi']['error']) {\n    weatherapi_dict = { \"date\": msg.payload['weatherapi']['current']['last_updated_epoch'] * 1000, \"value\": msg.payload['weatherapi']['current']['pressure_mb'] };\n} else {\n    missing_keys.push(\"weatherapi\");\n}\nvar openmeteoapi_dict = { \"date\": latest_time, \"value\": msg.payload['openmeteoapi']['hourly']['surface_pressure'][index]};\nif (!msg.payload['tommorowapi']['code']) {\n    tommorowapi_dict = { \"date\": Date.parse(msg.payload['tommorowapi']['data']['time']), \"value\": msg.payload['tommorowapi']['data']['values']['pressureSurfaceLevel'] };\n} else {\n    missing_keys.push(\"tommorowapi\");\n}\nif (msg.payload['openweather']['cod'] == 200) {\n    openweatherapi_dict = { \"date\": msg.payload['openweather']['dt'] * 1000, \"value\": msg.payload['openweather']['main']['pressure'] };\n} else {\n    missing_keys.push(\"openweatherapi\");\n}\nmsg.payload = [weatherapi_dict, openmeteoapi_dict, openweatherapi_dict, tommorowapi_dict];\nmsg.missing_keys = missing_keys;\nmsg.topic = \"pressure\";\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 320,
        "wires": [
            [
                "8fce24e929f52d06"
            ]
        ]
    },
    {
        "id": "aee8abb6d40c18b4",
        "type": "function",
        "z": "1c1d09cb50197133",
        "name": "Make list of visibility & dates",
        "func": "// wind speed is meters per second.\nconst currentTimestamp = Date.now();\nconst time_of_day = msg.payload['openmeteoapi']['hourly']['time'];\nvar latest_time = 0;\n// console.log(currentTimestamp);\nvar index = 0;\nfor(var time of time_of_day){\n    const time_ml = Date.parse(time);    // converts seconds to miliseconds.\n    if (time_ml <= currentTimestamp){\n        latest_time = time_ml;\n        index += 1;\n        console.log(latest_time);\n    } else {\n        break;\n    }\n}\nindex -= 1;\n// msg.payload = latest_time;\nvar weatherapi_dict = {};\nvar tommorowapi_dict = {};\nvar openweatherapi_dict = {};\nvar missing_keys = [];\nif (!msg.payload['weatherapi']['error']) {\n    weatherapi_dict = { \"date\": msg.payload['weatherapi']['current']['last_updated_epoch'] * 1000, \"value\": msg.payload['weatherapi']['current']['vis_km'] * 1000 };\n} else {\n    missing_keys.push(\"weatherapi\");\n}\nvar openmeteoapi_dict = { \"date\": latest_time, \"value\": msg.payload['openmeteoapi']['hourly']['visibility'][index]};\nif (!msg.payload['tommorowapi']['code']) {\n    tommorowapi_dict = { \"date\": Date.parse(msg.payload['tommorowapi']['data']['time']), \"value\": msg.payload['tommorowapi']['data']['values']['visibility'] * 1000 };\n} else {\n    missing_keys.push(\"tommorowapi\");\n}\nif (msg.payload['openweather']['cod'] == 200) {\n    openweatherapi_dict = { \"date\": msg.payload['openweather']['dt'] * 1000, \"value\": msg.payload['openweather']['visibility'] };\n} else {\n    missing_keys.push(\"openweatherapi\");\n}\nmsg.payload = [weatherapi_dict, openmeteoapi_dict, openweatherapi_dict, tommorowapi_dict];\nmsg.missing_keys=missing_keys;\nmsg.topic = \"visibility\";\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 360,
        "wires": [
            [
                "8fce24e929f52d06"
            ]
        ]
    },
    {
        "id": "0b21169bf4a24a6f",
        "type": "function",
        "z": "1c1d09cb50197133",
        "name": "Make list of humidity & dates",
        "func": "// wind speed is meters per second.\nconst currentTimestamp = Date.now();\nconst time_of_day = msg.payload['openmeteoapi']['hourly']['time'];\nvar latest_time = 0;\n// console.log(currentTimestamp);\nvar index = 0;\nfor(var time of time_of_day){\n    const time_ml = Date.parse(time);    // converts seconds to miliseconds.\n    if (time_ml <= currentTimestamp){\n        latest_time = time_ml;\n        index += 1;\n        console.log(latest_time);\n    } else {\n        break;\n    }\n}\nindex -= 1;\n\nvar weatherapi_dict = {};\nvar tommorowapi_dict = {};\nvar openweatherapi_dict = {};\nvar missing_keys = [];\nif (!msg.payload['weatherapi']['error']) {\n    weatherapi_dict = { \"date\": msg.payload['weatherapi']['current']['last_updated_epoch'] * 1000, \"value\": msg.payload['weatherapi']['current']['humidity'] };\n} else {\n    missing_keys.push(\"weatherapi\");\n}\nvar openmeteoapi_dict = { \"date\": latest_time, \"value\": msg.payload['openmeteoapi']['hourly']['relativehumidity_2m'][index]};\nif (!msg.payload['tommorowapi']['code']) {\n    tommorowapi_dict = { \"date\": Date.parse(msg.payload['tommorowapi']['data']['time']), \"value\": msg.payload['tommorowapi']['data']['values']['humidity'] };\n} else {\n    missing_keys.push(\"tommorowapi\");\n}\nif (msg.payload['openweather']['cod'] == 200) {\n    openweatherapi_dict = { \"date\": msg.payload['openweather']['dt'] * 1000, \"value\": msg.payload['openweather']['main']['humidity'] };\n} else {\n    missing_keys.push(\"openweatherapi\");\n}\nmsg.payload = [weatherapi_dict, openmeteoapi_dict, openweatherapi_dict, tommorowapi_dict];\nmsg.missing_keys =missing_keys;\nmsg.topic = \"humidity\";\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 400,
        "wires": [
            [
                "8fce24e929f52d06"
            ]
        ]
    },
    {
        "id": "c1d8d69c093a01f1",
        "type": "function",
        "z": "1c1d09cb50197133",
        "name": "Make list of cloud & dates",
        "func": "// wind speed is meters per second.\nconst currentTimestamp = Date.now();\nconst time_of_day = msg.payload['openmeteoapi']['hourly']['time'];\nvar latest_time = 0;\n// console.log(currentTimestamp);\nvar index = 0;\nfor(var time of time_of_day){\n    const time_ml = Date.parse(time);    // converts seconds to miliseconds.\n    if (time_ml <= currentTimestamp){\n        latest_time = time_ml;\n        index += 1;\n        console.log(latest_time);\n    } else {\n        break;\n    }\n}\nindex -= 1;\n// msg.payload = latest_time;\nconsole.log(index);\n// var weatherapi_dict = { \"date\": msg.payload['weatherapi']['current']['last_updated_epoch'] * 1000, \"value\": msg.payload['weatherapi']['current']['cloud']};\n// var openmeteoapi_dict = { \"date\": latest_time, \"value\": msg.payload['openmeteoapi']['hourly']['cloudcover'][index]};\n// var tommorowapi_dict = { \"date\": Date.parse(msg.payload['tommorowapi']['data']['time']), \"value\": msg.payload['tommorowapi']['data']['values']['cloudCover']};\n// var openweatherapi_dict = { \"date\": msg.payload['openweather']['dt'] * 1000, \"value\": msg.payload['openweather']['clouds']['all']};\n// msg.payload = [weatherapi_dict,openmeteoapi_dict,openweatherapi_dict,tommorowapi_dict];\n// msg.topic = \"cloud\";\n// return msg;\n\nvar weatherapi_dict = {};\nvar tommorowapi_dict = {};\nvar openweatherapi_dict = {};\nvar missing_keys = [];\nif (!msg.payload['weatherapi']['error']) {\n    weatherapi_dict = { \"date\": msg.payload['weatherapi']['current']['last_updated_epoch'] * 1000, \"value\": msg.payload['weatherapi']['current']['cloud'] };\n} else {\n    missing_keys.push(\"weatherapi\");\n}\nvar openmeteoapi_dict = { \"date\": latest_time, \"value\": msg.payload['openmeteoapi']['hourly']['cloudcover'][index]};\nif (!msg.payload['tommorowapi']['code']) {\n    tommorowapi_dict = { \"date\": Date.parse(msg.payload['tommorowapi']['data']['time']), \"value\": msg.payload['tommorowapi']['data']['values']['cloudCover'] };\n} else {\n    missing_keys.push(\"tommorowapi\");\n}\nif (msg.payload['openweather']['cod'] == 200) {\n    openweatherapi_dict = { \"date\": msg.payload['openweather']['dt'] * 1000, \"value\": msg.payload['openweather']['clouds']['all'] };\n} else {\n    missing_keys.push(\"openweatherapi\");\n}\nmsg.payload = [weatherapi_dict, openmeteoapi_dict, openweatherapi_dict, tommorowapi_dict];\nmsg.missing_keys = missing_keys;\nmsg.topic = \"cloud\";\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 440,
        "wires": [
            [
                "8fce24e929f52d06"
            ]
        ]
    },
    {
        "id": "a44e81c24ab2ed83",
        "type": "join",
        "z": "1c1d09cb50197133",
        "name": "",
        "mode": "custom",
        "build": "object",
        "property": "payload",
        "propertyType": "msg",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "accumulate": false,
        "timeout": "",
        "count": "2",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 1790,
        "y": 320,
        "wires": [
            [
                "445ca5f07bd03145",
                "cbbf2eeb493ddddd"
            ]
        ]
    },
    {
        "id": "0c475f2f2b341f84",
        "type": "function",
        "z": "1c1d09cb50197133",
        "name": "Returns only openweathermap",
        "func": "var value_weatherapi=0;\nvar value_tommorow=0;\nvar value_openweather=0;\nvar missing_keys = [];\nif (!msg.payload['weatherapi']['error']) {\n    value_weatherapi = msg.payload['weatherapi']['current']['last_updated_epoch'] * 1000;\n} else {\n    missing_keys.push(\"weatherapi\");\n}\nif (!msg.payload['tommorowapi']['code']) {\n    value_tommorow = Date.parse(msg.payload['tommorowapi']['data']['time']);\n} else {\n    missing_keys.push(\"tommorowapi\");\n}\nif (msg.payload['openweather']['cod'] == 200) {\n    value_openweather = msg.payload['openweather']['dt'] * 1000;\n} else {\n    missing_keys.push(\"openweatherapi\");\n}\nvar max_date = Math.max(value_weatherapi, value_tommorow, Date.parse(msg.payload['openmeteoapi']['current_weather']['time']), value_openweather);\nconsole.log(\"MAXDATE:\"+max_date);\n// console.log(\"DATE DEBUGGING =================== \");\n// console.log(\"WEATHER_API:\"+Date.parse(msg.payload['weatherapi']['current']['last_updated']));\n// console.log(\"OPENMETEO_API:\"+Date.parse(msg.payload['openmeteoapi']['current_weather']['time']));\n// console.log(\"TOMMOROW_API:\"+Date.parse(msg.payload['tommorowapi']['data']['time']));\n// console.log(\"OPENWEATHERMAP:\"+msg.payload['openweather']['dt'] * 1000);\n\n// var open = msg.payload[\"openweather\"];\n// open['dt'] = max_date;\n// msg.payload = {};\n// msg.payload = open;\n// msg.missing_keys = missing_keys;\n// msg.topic = \"openweather\";\n// return msg;\n\nif (msg.payload['openweather']['cod'] == 200) {\n    let open = msg.payload[\"openweather\"];\n    open['dt'] = max_date;\n    msg.payload = open;\n    msg.missing_keys = missing_keys;\n    msg.topic = \"openweather\";\n    return msg;\n\n}\nmsg.payload = {};\nlet open = {};\nlet lat = parseFloat(flow.get(\"lat\"));\nlet lng = parseFloat(flow.get(\"lng\"));\n// openweathermap['coord'] = msg.payload['openweather']['coord'];\n// openweathermap['weather'] = msg.payload['openweather']['weather'];\n// openweathermap['sys'] = msg.payload['openweather']['sys'];\n// openweathermap['name'] = msg.payload['openweather']['name'];\nopen[\"coord\"] = {\"lon\":lng,\"lat\":lat};\nopen[\"weather\"] = [{ \"id\": 0, \"main\": \"Unknown\", \"description\": \"unknown\", \"icon\":\"50d\"}];\nopen[\"name\"] = \"unknown\";\nopen[\"sys\"] = {\"country\":\"unknown\",\"sunrise\":\"unknown\",\"sunset\":\"unknown\"};\nopen['dt'] = max_date;\nmsg.payload = open;\nmsg.missing_keys = missing_keys;\nmsg.topic = \"openweather\";\n\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1070,
        "y": 140,
        "wires": [
            [
                "a44e81c24ab2ed83",
                "00c555a10f6dd30b"
            ]
        ]
    },
    {
        "id": "445ca5f07bd03145",
        "type": "function",
        "z": "1c1d09cb50197133",
        "name": "Puts avg data in Openweather map Template",
        "func": "var payload = msg.payload[\"avg_data\"][\"data\"];\n// var openweathermap = msg.payload['openweather'];\nvar openweathermap = {};\nopenweathermap['main'] = {};\nopenweathermap['visibility'] = {};\nopenweathermap['wind'] = {};\nopenweathermap['clouds'] = {};\nopenweathermap['coord'] = msg.payload['openweather']['coord'];\nopenweathermap['weather'] = msg.payload['openweather']['weather'];\nopenweathermap['sys'] = msg.payload['openweather']['sys'];\nopenweathermap['name'] = msg.payload['openweather']['name'];\n// openweathermap['main']['temp'] = payload['temperature'];\n// openweathermap['main']['pressure'] = payload['pressure'];\n// openweathermap['main']['humidity'] = payload['humidity'];\n// openweathermap['visibility'] = payload['visibility'];\n// openweathermap['wind']['speed'] = payload['wind_speed'];\n// openweathermap['clouds']['all'] = payload['cloud'];\n// openweathermap['wind']['deg'] = payload['wind_dir'];\nopenweathermap['main']['temp'] = parseFloat(payload['temperature'].toFixed(2));\nopenweathermap['main']['pressure'] = parseFloat(payload['pressure'].toFixed(2));\nopenweathermap['main']['humidity'] = parseFloat(payload['humidity'].toFixed(2));\nopenweathermap['visibility'] = parseFloat(payload['visibility'].toFixed(2));\nopenweathermap['wind']['speed'] = parseFloat(payload['wind_speed'].toFixed(2));\nopenweathermap['clouds']['all'] = parseFloat(payload['cloud'].toFixed(2));\nopenweathermap['wind']['deg'] = parseFloat(payload['wind_dir'].toFixed(2));\nopenweathermap['dt'] = msg.payload['openweather']['dt'];\ndelete openweathermap.main.feels_like;\ndelete openweathermap.main.temp_min;\ndelete openweathermap.main.temp_max;\nmsg.payload = {};\nmsg.payload = openweathermap;\nmsg.topic=\"\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1850,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "5d34355f66dfb6a5",
        "type": "function",
        "z": "1c1d09cb50197133",
        "name": "Make list of winddir & dates",
        "func": "// var weatherapi_dict = { \"date\": msg.payload['weatherapi']['current']['last_updated_epoch']*1000, \"value\": msg.payload['weatherapi']['current']['wind_degree']};\n// var openmeteoapi_dict = { \"date\": Date.parse(msg.payload['openmeteoapi']['current_weather']['time']), \"value\": msg.payload['openmeteoapi']['current_weather']['winddirection']};\n// var tommorowapi_dict = { \"date\": Date.parse(msg.payload['tommorowapi']['data']['time']), \"value\": msg.payload['tommorowapi']['data']['values']['windDirection'] };\n// var openweatherapi_dict = { \"date\": msg.payload['openweather']['dt'] * 1000, \"value\": msg.payload['openweather']['wind']['deg']};\n// msg.payload = [weatherapi_dict,openmeteoapi_dict,openweatherapi_dict,tommorowapi_dict];\n// msg.topic = \"wind_dir\";\n// return msg;\nvar weatherapi_dict = {};\nvar openmeteoapi_dict = {};\nvar tommorowapi_dict = {};\nvar openweatherapi_dict = {};\nvar missing_keys=[];\nif (!msg.payload['weatherapi']['error']) {\n    weatherapi_dict = { \"date\": msg.payload['weatherapi']['current']['last_updated_epoch'] * 1000, \"value\": msg.payload['weatherapi']['current']['wind_degree'] };\n} else {\n    missing_keys.push(\"weatherapi\");\n}\nif (!msg.payload['tommorowapi']['code']) {\n    tommorowapi_dict = { \"date\": Date.parse(msg.payload['tommorowapi']['data']['time']), \"value\": msg.payload['tommorowapi']['data']['values']['windDirection'] };\n} else {\n    missing_keys.push(\"tommorowapi\");\n}\nif (msg.payload['openweather']['cod'] == 200) {\n    openweatherapi_dict = { \"date\": msg.payload['openweather']['dt'] * 1000, \"value\": msg.payload['openweather']['wind']['deg'] };\n} else {\n    missing_keys.push(\"openweatherapi\");\n}\nopenmeteoapi_dict = { \"date\": Date.parse(msg.payload['openmeteoapi']['current_weather']['time']), \"value\": msg.payload['openmeteoapi']['current_weather']['winddirection'] };\nmsg.payload = [weatherapi_dict, openmeteoapi_dict, openweatherapi_dict, tommorowapi_dict];\nmsg.missing_keys = missing_keys;\nmsg.topic = \"wind_dir\";\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 200,
        "wires": [
            [
                "8fce24e929f52d06"
            ]
        ]
    },
    {
        "id": "73328df888037b2c",
        "type": "inject",
        "z": "1c1d09cb50197133",
        "name": "Test Inject",
        "props": [
            {
                "p": "payload.data",
                "v": "{\"temperature\":[{\"value\":20,\"date\":1664515200000},{\"value\":23,\"date\":1664774400000},{\"value\":18,\"date\":1664428800000},{\"value\":25,\"date\":1664601600000},{\"value\":22,\"date\":1664688000000}],\"humidity\":[{\"value\":20,\"date\":1664515200000},{\"value\":23,\"date\":1664774400000},{\"value\":18,\"date\":1664428800000},{\"value\":25,\"date\":1664601600000},{\"value\":22,\"date\":1664688000000}]}",
                "vt": "json"
            },
            {
                "p": "payload.reverse_sort",
                "v": "true",
                "vt": "bool"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1160,
        "y": 620,
        "wires": [
            [
                "fee3903a5b91d9a4"
            ]
        ]
    },
    {
        "id": "8fce24e929f52d06",
        "type": "join",
        "z": "1c1d09cb50197133",
        "name": "",
        "mode": "custom",
        "build": "object",
        "property": "payload",
        "propertyType": "msg",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "accumulate": false,
        "timeout": "",
        "count": "7",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 1230,
        "y": 360,
        "wires": [
            [
                "a566ad1ee0b041dd",
                "a10ab78339067de8"
            ]
        ]
    },
    {
        "id": "a566ad1ee0b041dd",
        "type": "debug",
        "z": "1c1d09cb50197133",
        "name": "debug 65",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1140,
        "y": 500,
        "wires": []
    },
    {
        "id": "cbbf2eeb493ddddd",
        "type": "debug",
        "z": "1c1d09cb50197133",
        "name": "debug 66",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 2000,
        "y": 320,
        "wires": []
    },
    {
        "id": "b6f1d7bfaf0f6e98",
        "type": "change",
        "z": "1c1d09cb50197133",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "avg_data",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1750,
        "y": 420,
        "wires": [
            [
                "a44e81c24ab2ed83"
            ]
        ]
    },
    {
        "id": "fee3903a5b91d9a4",
        "type": "change",
        "z": "1c1d09cb50197133",
        "name": "REVERSE SORT TRUE",
        "rules": [
            {
                "t": "set",
                "p": "payload.reverse_sort",
                "pt": "msg",
                "to": "true",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1410,
        "y": 600,
        "wires": [
            [
                "47508ce9e9f95567"
            ]
        ]
    },
    {
        "id": "a10ab78339067de8",
        "type": "function",
        "z": "1c1d09cb50197133",
        "name": "Correct data set",
        "func": "var data = msg.payload;\n// Remove empty values for each key\nfor (const key in data) {\n    if (Array.isArray(data[key])) {\n        data[key] = data[key].filter(item => Object.keys(item).length !== 0);\n    }\n}\nmsg.payload = {};\nmsg.payload[\"data\"] = data;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 520,
        "wires": [
            [
                "fee3903a5b91d9a4"
            ]
        ]
    },
    {
        "id": "47508ce9e9f95567",
        "type": "subflow:668a9e3b55094c55",
        "z": "1c1d09cb50197133",
        "name": "",
        "x": 1660,
        "y": 600,
        "wires": [
            [
                "51a9326395a34bc4"
            ]
        ]
    },
    {
        "id": "51a9326395a34bc4",
        "type": "subflow:a833c5f1efa92886",
        "z": "1c1d09cb50197133",
        "name": "",
        "x": 1750,
        "y": 480,
        "wires": [
            [
                "b6f1d7bfaf0f6e98"
            ]
        ]
    },
    {
        "id": "f1ae844bf041de78",
        "type": "delay",
        "z": "1c1d09cb50197133",
        "name": "",
        "pauseType": "delay",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 200,
        "y": 60,
        "wires": [
            [
                "f5e296816b0a808e"
            ]
        ]
    },
    {
        "id": "00c555a10f6dd30b",
        "type": "function",
        "z": "1c1d09cb50197133",
        "name": "Alert Missing API_Keys",
        "func": "const missing_keys = msg.missing_keys;\nif (missing_keys && missing_keys.length == 0) {\n    return [null, msg];\n}\nlet s = \"The Following Keys are not valid or not properly configured: \";\nfor (let mk of missing_keys) {\n    if (mk === \"openweatherapi\") {\n        s += mk + \" (openweatherapi key loss will result in data-loss in gui), \";\n    } else {\n        s += mk + \", \";\n    }\n}\ns = s.slice(0, -2) + \".\";\nif (missing_keys.length == 3) {\n    s += \" The only accessible api is openmeteo (collecting data only from there).\"\n}\nmsg.payload = s;\nreturn [msg, null];",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1370,
        "y": 40,
        "wires": [
            [
                "b94ec6cc34249f4c"
            ],
            []
        ]
    },
    {
        "id": "b94ec6cc34249f4c",
        "type": "debug",
        "z": "1c1d09cb50197133",
        "name": "Missing Keys debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1660,
        "y": 40,
        "wires": []
    }
]